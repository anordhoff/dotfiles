# --------------------------------------
# general
# --------------------------------------

# start tmux on shell launch, attaching to (or creating a) session 'dotfiles'
[ -z $TMUX ] && tmux new-session -A -s dotfiles

# options
setopt   dotglob      # include hidden files in expansion and completion
setopt   extendedglob # treat '#', '~', and '^' as part of patterns
setopt   nomatch      # print an error if no filename matches pattern
unsetopt flowcontrol  # disable suspending terminal with ctrl-s

# directory stack options 
setopt autopushd       # make cd push the old directory onto the dir stack
setopt pushdignoredups # do not push copies of the same dir onto the dir stack
setopt pushdsilent     # do not print the dir stack after pushd or popd

# disable beeping
unsetopt beep
unsetopt histbeep
unsetopt listbeep

# print current working directory and exit code in the prompt
PS1='%F{blue}%60<...<%~%F{default}%(?.. (%?%)) $ '

# use emacs mode for zle
bindkey -e

# bash-like navigation
autoload -Uz select-word-style
select-word-style bash

# delete key
bindkey "^[[3~" delete-char

# delete the line before the cursor, rather than entire line (to mimic bash)
bindkey '^U' backward-kill-line

# delete the word behind cursor up to the next whitespace
# https://unix.stackexchange.com/questions/572439/make-ctrl-w-and-ctrl-alt-h-in-zsh-behave-the-same-as-in-bash
zle -N backward-kill-space-word
backward-kill-space-word() {
  zle -f kill
  WORDCHARS='*?_-.[]~=/&;!#$%^(){}<>' zle .backward-kill-word
}
bindkey '^W' backward-kill-space-word

# ctrl-x_ctrl-e opens the current command in the editor
autoload -Uz edit-command-line
zle -N edit-command-line
bindkey '^X^E' edit-command-line

# use 'run-help' command for zsh built-ins
autoload -Uz run-help

# lazyload functions
typeset -U fpath
fpath=(~/dotfiles/zsh/functions $fpath) && autoload ${fpath[1]}/*(:t)


# --------------------------------------
# history
# --------------------------------------

HISTFILE=~/.zhistory
HISTSIZE=10000
SAVEHIST=10000

setopt extendedhistory   # save start time and length of time commands run
setopt histignorealldups # keep only the most recently added duplicate command
setopt histignorespace   # commands that start with a space are not written
setopt histnostore       # history and fc commands are not written to history
setopt histreduceblanks  # remove excess spaces before writing a comman
setopt incappendhistory  # update the history file after each executed command

# match typed command and arguments when moving through history
autoload -Uz up-line-or-beginning-search
autoload -Uz down-line-or-beginning-search
zle -N up-line-or-beginning-search
zle -N down-line-or-beginning-search
bindkey '^[[A' up-line-or-beginning-search
bindkey '^[[B' down-line-or-beginning-search
bindkey '^P' up-line-or-beginning-search
bindkey '^N' down-line-or-beginning-search


# --------------------------------------
# completion
# --------------------------------------

# TODO: touch hello-app.yaml; touch hello-app-service.yaml; kubectl apply -f
# helo<tab>   should result in 'hello-app', rather than resulting in 'hell' and
# selecting first option in menu

setopt   alwaystoend    # completion in a word will move cursor to end of word
setopt   completeinword # completion takes place at the cursor position in word
unsetopt listtypes      # don't show filetypes in completion menu

# add completion directories to fpath
fpath=(~/dotfiles/zsh/completions $fpath)

# load the completion module
autoload -Uz compinit
zmodload zsh/complist

# automatically load bash completion functions
autoload -U +X bashcompinit && bashcompinit

# run compinit if ~/jobfiles/zsh does not exist
[ ! -d ~/jobfiles/zsh ] && compinit

# go backwards in completion menu using shift-tab
bindkey -M menuselect '^[[Z' reverse-menu-complete

# allow one error
zstyle ':completion:*' max-errors 1

# smart case completion; complete partial words
zstyle ':completion:*:complete-extended:*' \
  matcher-list 'm:{a-z-_}={A-Z_-}' 'r:|[._-]=* r:|=*' 'l:|=* r:|=*'

# complete *. with extensions; standard; one error; case insensitive completion
zstyle ':completion:*' completer \
  _extensions _complete _approximate _complete:-extended

# cache completions
zstyle ':completion:*' use-cache true
zstyle ':completion:*' cache-path ~/.zcompcache

# use a completion menu
zstyle ':completion:*' menu select

# show help and warning messages
zstyle ':completion:*:messages' format '-- %d --'
zstyle ':completion:*:warnings' format '-- no matches found --'

# use colors in completion menu
zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS}

# enable improved git-completion
zstyle ':completion:*:*:git:*' script ~/dotfiles/zsh/extensions/git-completion.bash


# --------------------------------------
# alias
# --------------------------------------

# unalias default run-help alias to man; alias help to run-help
(( ${+aliases[run-help]} )) && unalias run-help
alias help=run-help

# refresh watch every second; work with aliases
alias watch='watch -n 1 '

# diff files in an editor
alias ediff='nvim -d'

# open the notes dir
alias n='nvim ~/notes/misc.md'

# directory stack
alias dirs='dirs -v'
for i in {0..9}; do
  alias d${i}="cd +${i}"
done

# grep colors
alias grep='grep --color=auto'
alias egrep='egrep --color=auto'
alias fgrep='fgrep --color=auto'

# use gnu ls on bsd (bsd ls does not have --group-directories-first)
if [[ $OSTYPE =~ "darwin"* ]]; then
  alias l='gls -lhA --color=auto --group-directories-first'
  alias ll='gls -lh --color=auto --group-directories-first'
  alias ls='gls --color=auto --group-directories-first'
else
  alias l='ls -lhA --color=auto --group-directories-first'
  alias ll='ls -lh --color=auto --group-directories-first'
  alias ls='ls --color=auto --group-directories-first'
fi

if [[ $OSTYPE =~ "darwin"* ]]; then
  alias python="$BREW_PREFIX/bin/python3"
  alias pip="$BREW_PREFIX/bin/pip3"
fi

# global cd shorthand
alias -g ...='../..'
alias -g ....='../../..'
alias -g .....='../../../..'
alias -g ......='../../../../..'

# git
alias    g='git'
alias   ga='git add'
alias   gb='git branch'
alias  gbl='git blame'
alias   gc='git commit -v'
alias  gcl='git clone'
alias  gcm='git commit -m'
alias  gco='git checkout'
alias gcob='git checkout -b'
alias   gd='git diff'
alias   gf='git fetch'
alias gfom='git fetch origin master:master'
alias   gl='git log'
alias  glo='git log --oneline'
alias   gm='git merge'
alias  gmt='git mergetool'
alias   gp='git pull'
alias  gpu='git push'
alias   gr='git reset'
alias  grb='git rebase'
alias  grv='git remote --verbose'
alias   gs='git status'
alias  gst='git stash'
alias  gsh='git show'

# kubernetes
alias  k='kubectl'
alias ka='kubectl apply'
alias kd='kubectl describe'
alias ke='kubectl explain'
alias kg='kubectl get'
alias kl='kubectl logs'

# krew plugins
alias kctx='kubectl ctx'
alias  kns='kubectl ns'


# --------------------------------------
# extensions
# --------------------------------------

# enable expand-multiple-dots.zsh
[ -r ~/dotfiles/zsh/extensions/expand-multiple-dots.zsh ] \
  && source ~/dotfiles/zsh/extensions/expand-multiple-dots.zsh

# enable tab-on-empty-line-shows-files.zsh
[ -r ~/dotfiles/zsh/extensions/expand-or-complete-or-list-files.zsh ] \
  && source ~/dotfiles/zsh/extensions/expand-or-complete-or-list-files.zsh

# enable fzf (except in vim)
if [ -z $VIM ]; then
  if [[ $OSTYPE =~ "darwin"* ]]; then
    [ -r $BREW_PREFIX/opt/fzf/shell/completion.zsh ] \
      && source $BREW_PREFIX/opt/fzf/shell/completion.zsh
    [ -r $BREW_PREFIX/opt/fzf/shell/key-bindings.zsh ] \
      && source $BREW_PREFIX/opt/fzf/shell/key-bindings.zsh
  else
    [ -r /usr/share/fzf/shell/completion.zsh ] \
      && source /usr/share/fzf/shell/completion.zsh
    [ -r /usr/share/fzf/shell/key-bindings.zsh ] \
      && source /usr/share/fzf/shell/key-bindings.zsh
  fi
fi


# --------------------------------------
# misc
# --------------------------------------

# source work zshrc
[ -r ~/jobfiles/zsh/zshrc ] && source ~/jobfiles/zsh/zshrc

if [[ $OSTYPE =~ "darwin"* ]]; then
  path=($BREW_PREFIX/opt/openssl@3/bin $path)
fi
